# Encryption Session Design ‚Äî `/session/init` and `/session/init/anon`
_Date: 2026-01-18_

This document defines a **single, consistent encryption flow** for **Partners + Web + Mobile** using:

- **No mTLS**
- **Opaque access tokens**
- **No `/public-key` endpoint**
- **Session-based encryption only** (ECDH + HKDF ‚Üí AES-256-GCM)
- **IV / Tag / AAD in headers**
- **Ciphertext in body**

> **Goal:** Encrypt **every request and response** (including pre-login OTP flows) while keeping internal microservices free of auth/crypto concerns.

---

## 1) High-level architecture

```
Client (Web/Mobile/Partner)
        |
        v
      APIM  (rate limit, routing, optional introspect call)
        |
        v
Sidecar/Crypto Layer (decrypt + replay + encrypt)
        |
        v
Internal Microservice (pure business JSON)
```

- **Identity Service** issues tokens and provides **/introspect** for opaque tokens.
- **Crypto/Session Service** hosts `/session/init` and `/session/init/anon` (recommended centralized service).
- **Sidecars** decrypt/encrypt using session keys stored in **Redis** (shared).

---

## 2) Session endpoints

### 2.1 Anonymous Session Init (bootstrap)
Use this before login to encrypt endpoints like `/otp/generate` and `/otp/verify`.

- **Endpoint:** `POST /session/init/anon`
- **Auth:** ‚ùå none
- **TTL:** ‚úÖ 120 seconds (2 minutes)
- **Usage:** Only for **pre-login** endpoints (strict allowlist)

### 2.2 Authenticated Session Init
Use after login (token available) for all business APIs.

- **Endpoint:** `POST /session/init`
- **Auth:** ‚úÖ `Authorization: Bearer <opaque_access_token>`
- **TTL:** ‚úÖ 30 minutes recommended (or up to 1 hour)

---

## 3) Required headers (both endpoints)

These headers are required for replay protection and auditing.

| Header | Example | Generated By | Notes |
|---|---|---|---|
| `X-Nonce` | UUID | Client | Must be client-generated |
| `X-Timestamp` | epoch ms | Client | Used for timestamp window checks |
| `Content-Type` | `application/json` | Client | For session init body |

### Why not Apptrana Request-Id?
Apptrana injects request-id **after** request leaves the client, so it cannot be used for cryptographic replay protection.

---

## 4) Request/Response schema (session init)

### 4.1 Request body (client ‚Üí server)

Client sends its ephemeral ECDH public key (base64):

```json
{
  "keyAgreement": "ECDH_P256",
  "clientPublicKey": "BASE64_CLIENT_PUBLIC_KEY",
  "ttlSec": 120
}
```

- `keyAgreement`: fixed `"ECDH_P256"`
- `clientPublicKey`: Base64 encoded ECDH public key bytes
- `ttlSec`: optional; server caps based on endpoint rules

### 4.2 Response body (server ‚Üí client)

```json
{
  "sessionId": "A-1c3f5a9b12ef",
  "serverPublicKey": "BASE64_SERVER_PUBLIC_KEY",
  "encAlg": "A256GCM",
  "expiresInSec": 120
}
```

---

## 5) Crypto fundamentals (step-by-step)

### 5.1 What the client generates
Client generates an **ephemeral ECDH keypair**:

- `clientPriv` (private key) ‚Äî stays on client
- `clientPub` (public key) ‚Äî sent to server in `/session/init*`

### 5.2 What the server generates
Server generates its own **ephemeral ECDH keypair**:

- `serverPriv` (private key) ‚Äî stays on server
- `serverPub` (public key) ‚Äî returned to client from `/session/init*`

### 5.3 Shared secret using ECDH
Both sides compute the same shared secret:

- Server computes: `sharedSecret = ECDH(serverPriv, clientPub)`
- Client computes: `sharedSecret = ECDH(clientPriv, serverPub)`

These are identical by ECDH properties.

### 5.4 Deriving the AES key (HKDF)
Both sides derive the same AES key (32 bytes):

```
sessionKey = HKDF-SHA256(
  IKM  = sharedSecret,
  salt = sessionId,
  info = "SESSION|A256GCM|<ANON|AUTH>|<clientContext>",
  len  = 32 bytes
)
```

This becomes the AES-256-GCM key.

---

## 6) Redis storage design

Server stores `sessionKey` in Redis, keyed by sessionId.

- Key: `sess:<sessionId>`
- Value: `sessionKey (32 bytes)` + metadata (type, expiry, principal optional)
- TTL:
  - anon: 120 sec
  - auth: 1800 sec (30 min) or 3600 sec (1 hr)

Example:
```
sess:A-1c3f5a9b12ef -> key=..., type=ANON, expiresAt=...
sess:S-8f2c1a9b4e1d -> key=..., type=AUTH, principal=INV123, expiresAt=...
```

---

## 7) Enforcement rules (critical)

### 7.1 Anonymous sessions restricted
Session ids prefixed with `A-` are **anonymous**.

They must be accepted only for a strict allowlist such as:

- `/otp/generate`
- `/otp/verify`
- `/auth/login` (if needed)

If `X-Kid: session:A-...` is used on business APIs ‚Üí **403**.

### 7.2 Authenticated sessions for all business APIs
Session ids prefixed with `S-` are authenticated.

Business APIs require:
- valid opaque token (`Authorization`)
- `X-Kid` referencing an authenticated session

---

## 8) Encrypted API contract (for all business calls)

You requested **IV, Tag, AAD in headers** and ciphertext in body.

### 8.1 Request headers (encrypted request)

| Header | Example | Required |
|---|---|---|
| `Authorization` | `Bearer opq_xxx` | AUTH session only |
| `X-Kid` | `session:S-8f2...` | ‚úÖ |
| `X-Enc-Alg` | `A256GCM` | ‚úÖ |
| `X-IV` | Base64(12 bytes) | ‚úÖ |
| `X-Tag` | Base64(16 bytes) | ‚úÖ |
| `X-AAD` | Base64(bytes) | ‚úÖ |
| `X-Nonce` | UUID | ‚úÖ |
| `X-Timestamp` | epoch ms | ‚úÖ |

Body:
- ciphertext only (base64 string or raw bytes)

### 8.2 Response headers (encrypted response)
Same pattern:

- `X-Kid`, `X-Enc-Alg`, `X-IV`, `X-Tag`, `X-AAD`
- ciphertext in body

---

## 9) AAD construction (recommended)

AAD should bind request identity to ciphertext integrity.

Recommended AAD plaintext (before base64):

```
METHOD|PATH|TIMESTAMP|NONCE|KID
```

Example:
```
POST|/transactions/purchase|1768710402456|4b70...|session:S-8f2...
```

Client:
- builds AAD bytes from the string
- passes base64(AAD) in header `X-AAD`

Server:
- reconstructs the same AAD bytes and uses it during AES-GCM decrypt

---

## 10) Full examples

### 10.1 Anonymous session init
**Request**
```
POST /session/init/anon
X-Nonce: 8b2b6a8f-3a1a-4d46-8f4d-1b00c2b2d3aa
X-Timestamp: 1768710400123
Content-Type: application/json
```

```json
{
  "keyAgreement": "ECDH_P256",
  "clientPublicKey": "B64_CLIENT_PUB",
  "ttlSec": 120
}
```

**Response**
```json
{
  "sessionId": "A-1c3f5a9b12ef",
  "serverPublicKey": "B64_SERVER_PUB",
  "encAlg": "A256GCM",
  "expiresInSec": 120
}
```

### 10.2 Authenticated session init
**Request**
```
POST /session/init
Authorization: Bearer opq_abc123...
X-Nonce: 7d25a9a2-6c28-4d4b-90bf-b3c03b9f1690
X-Timestamp: 1768710450000
Content-Type: application/json
```

```json
{
  "keyAgreement": "ECDH_P256",
  "clientPublicKey": "B64_CLIENT_PUB",
  "ttlSec": 1800
}
```

**Response**
```json
{
  "sessionId": "S-8f2c1a9b4e1d",
  "serverPublicKey": "B64_SERVER_PUB",
  "encAlg": "A256GCM",
  "expiresInSec": 1800
}
```

### 10.3 Encrypted business API call
**Plain JSON**
```json
{ "schemeCode": "AEF", "amount": 5000 }
```

**Request**
```
POST /transactions/purchase
Authorization: Bearer opq_abc123...
X-Kid: session:S-8f2c1a9b4e1d
X-Enc-Alg: A256GCM
X-IV: p3hT8v0x+mvzKQ==
X-Tag: 1Gf3oWbB2Z7q8A==
X-AAD: UE9TVHwvdHJhbnNhY3Rpb25zL3B1cmNoYXNlfDE3Njg3MTA0MDI0NTZ8NGI3MGQ5...
X-Nonce: 4b70d9f7-8c7a-4c55-b1f8-7c0e8e4c6cf2
X-Timestamp: 1768710402456
Content-Type: application/octet-stream
```

Body:
```
mUO7e...==
```

**Response**
```
200 OK
X-Kid: session:S-8f2c1a9b4e1d
X-Enc-Alg: A256GCM
X-IV: Q2l2Y0pOQ2x0ZQ==
X-Tag: pJ8xK9fL2uQ8LA==
X-AAD: MjAwfC90cmFuc2FjdGlvbnMvcHVyY2hhc2V8MTc2...
Content-Type: application/octet-stream
```

Body:
```
m9a1...==
```

---

## 11) Node.js TypeScript reference implementation

> These snippets are suitable for PoC. In production use Redis instead of in-memory maps and add strict validation + rate limiting.

### 11.1 Shared crypto helpers (`crypto-helpers.ts`)
```ts
import crypto from "crypto";

export const b64 = (buf: Buffer) => buf.toString("base64");
export const unb64 = (s: string) => Buffer.from(s, "base64");

export function createEcdhKeypair() {
  const ecdh = crypto.createECDH("prime256v1"); // P-256
  ecdh.generateKeys();
  return { ecdh, publicKey: ecdh.getPublicKey() };
}

export function hkdf32(sharedSecret: Buffer, salt: Buffer, info: Buffer) {
  return crypto.hkdfSync("sha256", sharedSecret, salt, info, 32);
}

export function aesGcmEncrypt(key32: Buffer, iv12: Buffer, aad: Buffer, plaintext: Buffer) {
  const cipher = crypto.createCipheriv("aes-256-gcm", key32, iv12);
  cipher.setAAD(aad);
  const ciphertext = Buffer.concat([cipher.update(plaintext), cipher.final()]);
  const tag = cipher.getAuthTag();
  return { ciphertext, tag };
}

export function aesGcmDecrypt(key32: Buffer, iv12: Buffer, aad: Buffer, ciphertext: Buffer, tag: Buffer) {
  const decipher = crypto.createDecipheriv("aes-256-gcm", key32, iv12);
  decipher.setAAD(aad);
  decipher.setAuthTag(tag);
  return Buffer.concat([decipher.update(ciphertext), decipher.final()]);
}

export function buildAad(method: string, path: string, ts: string, nonce: string, kid: string) {
  return Buffer.from(`${method}|${path}|${ts}|${nonce}|${kid}`, "utf8");
}
```

### 11.2 Session service (Express) (`session-service.ts`)
```ts
import express from "express";
import crypto from "crypto";
import { b64, unb64, createEcdhKeypair, hkdf32 } from "./crypto-helpers";

const app = express();
app.use(express.json());

// DEMO storage (replace with Redis)
const sessions = new Map<string, { key: Buffer; type: "ANON" | "AUTH"; expiresAt: number }>();

function storeSession(sessionId: string, key: Buffer, type: "ANON" | "AUTH", ttlSec: number) {
  sessions.set(sessionId, { key, type, expiresAt: Date.now() + ttlSec * 1000 });
}

// DEMO introspect (replace with Identity /introspect)
async function introspectToken(token?: string) {
  if (token?.startsWith("opq_")) return { active: true, sub: "INV123", clientId: "WEB_APP" };
  return { active: false };
}

function requireNonceTs(req: express.Request, res: express.Response) {
  const nonce = req.header("x-nonce");
  const ts = req.header("x-timestamp");
  if (!nonce || !ts) {
    res.status(400).json({ error: "MISSING_NONCE_OR_TIMESTAMP" });
    return null;
  }
  return { nonce, ts };
}

// /session/init/anon
app.post("/session/init/anon", (req, res) => {
  const hdr = requireNonceTs(req, res);
  if (!hdr) return;

  const { clientPublicKey } = req.body;
  if (!clientPublicKey) return res.status(400).json({ error: "MISSING_CLIENT_PUBLIC_KEY" });

  const clientPub = unb64(clientPublicKey);
  const { ecdh: serverECDH, publicKey: serverPub } = createEcdhKeypair();

  const sharedSecret = serverECDH.computeSecret(clientPub);

  const sessionId = "A-" + crypto.randomBytes(8).toString("hex");
  const ttlSec = 120;

  const salt = Buffer.from(sessionId, "utf8");
  const info = Buffer.from("SESSION|A256GCM|ANON", "utf8");
  const sessionKey = hkdf32(sharedSecret, salt, info);

  storeSession(sessionId, sessionKey, "ANON", ttlSec);

  res.json({ sessionId, serverPublicKey: b64(serverPub), encAlg: "A256GCM", expiresInSec: ttlSec });
});

// /session/init
app.post("/session/init", async (req, res) => {
  const hdr = requireNonceTs(req, res);
  if (!hdr) return;

  const auth = req.header("authorization");
  const token = auth?.startsWith("Bearer ") ? auth.slice(7) : undefined;

  const it = await introspectToken(token);
  if (!it.active) return res.status(401).json({ error: "INVALID_TOKEN" });

  const { clientPublicKey, ttlSec } = req.body;
  if (!clientPublicKey) return res.status(400).json({ error: "MISSING_CLIENT_PUBLIC_KEY" });

  const clientPub = unb64(clientPublicKey);
  const { ecdh: serverECDH, publicKey: serverPub } = createEcdhKeypair();

  const sharedSecret = serverECDH.computeSecret(clientPub);

  const sessionId = "S-" + crypto.randomBytes(8).toString("hex");
  const allowedTtl = Math.min(Math.max(ttlSec ?? 1800, 300), 3600);

  const salt = Buffer.from(sessionId, "utf8");
  const info = Buffer.from(`SESSION|A256GCM|AUTH|${it.clientId}|${it.sub}`, "utf8");
  const sessionKey = hkdf32(sharedSecret, salt, info);

  storeSession(sessionId, sessionKey, "AUTH", allowedTtl);

  res.json({ sessionId, serverPublicKey: b64(serverPub), encAlg: "A256GCM", expiresInSec: allowedTtl });
});

app.listen(3000, () => console.log("Session service listening on :3000"));
```

---

## 12) Production notes (do these for real)
- Store sessions in **Redis**, not memory
- Add strict allowlist enforcement for `A-` sessions
- Add strict rate limits for `/session/init/anon`
- Reject large payloads for anon endpoints
- Always validate:
  - `X-Enc-Alg == A256GCM`
  - IV length == 12 bytes
  - Tag length == 16 bytes

---

## 13) Replay protection

### 13.1 Timestamp window
Requests must include `X-Timestamp` within **¬±5 minutes** of server time.

### 13.2 Nonce uniqueness
Server stores nonces in Redis with TTL matching timestamp window:

- Key: `nonce:<X-Nonce>`
- Value: `1`
- TTL: 300 seconds

If nonce already exists ‚Üí reject with `400 CRYPTO_ERROR`.

### 13.3 Redis schema (complete)
```
sess:S-xxxx       ‚Üí {key, type, expiresAt, principal}   TTL: 1800s (or up to 3600s)
sess:A-xxxx       ‚Üí {key, type, expiresAt}              TTL: 120s
nonce:<uuid>      ‚Üí 1                                   TTL: 300s
```

---

## 14) Security validations

### 14.1 Client public key validation
Before computing ECDH shared secret, server **MUST** validate:

1. Key is valid uncompressed P-256 point (65 bytes: `0x04 || X || Y`)
2. Point lies on the P-256 curve

Reject with `400 CRYPTO_ERROR` if validation fails.

### 14.2 Session ID entropy
Session IDs should use **16 bytes (128 bits)** of cryptographic randomness:

```ts
const sessionId = "S-" + crypto.randomBytes(16).toString("hex"); // 32 hex chars
```

### 14.3 IV generation rules
- **Client** generates IV for request encryption
- **Server** generates IV for response encryption
- IVs must be **12 bytes** of cryptographic randomness
- **Never reuse** an IV with the same key

### 14.4 Error response policy
All decryption/validation failures return a **generic error**:

```json
{ "error": "CRYPTO_ERROR" }
```

Do **not** reveal specific failure reasons (IV length, tag mismatch, point not on curve, etc.) to prevent oracle attacks.

### 14.5 Rate limiting (APIM deployment requirement)
Rate limiting is **not** part of the crypto design but must be configured at APIM:

| Endpoint | Rate Limit | Rationale |
|---|---|---|
| `/session/init/anon` | 10/min per IP | Prevent DoS (expensive ECDH computation) |
| `/session/init` | 30/min per token | Less critical (already authenticated) |

---

## 15) Updated reference implementation (with replay protection)

### 15.1 Replay protection helper (`crypto-helpers.ts` additions)

```ts
import { Redis } from "ioredis";

const TIMESTAMP_WINDOW_MS = 5 * 60 * 1000; // ¬±5 minutes
const NONCE_TTL_SEC = 300;

export async function validateReplayProtection(
  redis: Redis,
  nonce: string,
  timestamp: string
): Promise<void> {
  const ts = parseInt(timestamp, 10);
  const now = Date.now();

  // 1. Timestamp window check
  if (isNaN(ts) || Math.abs(now - ts) > TIMESTAMP_WINDOW_MS) {
    throw new Error("TIMESTAMP_INVALID");
  }

  // 2. Nonce uniqueness (atomic check-and-set)
  const key = `nonce:${nonce}`;
  const wasSet = await redis.set(key, "1", "EX", NONCE_TTL_SEC, "NX");

  if (!wasSet) {
    throw new Error("REPLAY_DETECTED");
  }
}
```

### 15.2 Public key validation helper

```ts
import crypto from "crypto";

export function validateP256PublicKey(publicKeyBytes: Buffer): void {
  // P-256 uncompressed point: 0x04 || X (32 bytes) || Y (32 bytes) = 65 bytes
  if (publicKeyBytes.length !== 65) {
    throw new Error("INVALID_KEY_LENGTH");
  }

  if (publicKeyBytes[0] !== 0x04) {
    throw new Error("INVALID_KEY_FORMAT");
  }

  // Use Node.js crypto to validate point is on curve
  try {
    const keyObject = crypto.createPublicKey({
      key: Buffer.concat([
        // SPKI header for P-256 uncompressed point
        Buffer.from("3059301306072a8648ce3d020106082a8648ce3d030107034200", "hex"),
        publicKeyBytes,
      ]),
      format: "der",
      type: "spki",
    });

    // If we get here, the point is valid and on the curve
    if (keyObject.asymmetricKeyType !== "ec") {
      throw new Error("INVALID_KEY_TYPE");
    }
  } catch (e) {
    throw new Error("POINT_NOT_ON_CURVE");
  }
}
```

### 15.3 Updated session service with all validations

```ts
import express from "express";
import crypto from "crypto";
import { Redis } from "ioredis";
import {
  b64,
  unb64,
  createEcdhKeypair,
  hkdf32,
  validateReplayProtection,
  validateP256PublicKey,
} from "./crypto-helpers";

const app = express();
app.use(express.json());

const redis = new Redis(); // Configure for production

function storeSession(
  sessionId: string,
  key: Buffer,
  type: "ANON" | "AUTH",
  ttlSec: number,
  principal?: string
) {
  const value = JSON.stringify({
    key: b64(key),
    type,
    expiresAt: Date.now() + ttlSec * 1000,
    ...(principal && { principal }),
  });
  return redis.set(`sess:${sessionId}`, value, "EX", ttlSec);
}

async function introspectToken(token?: string) {
  // Replace with actual Identity /introspect call
  if (token?.startsWith("opq_")) return { active: true, sub: "INV123", clientId: "WEB_APP" };
  return { active: false };
}

function requireNonceTs(req: express.Request, res: express.Response) {
  const nonce = req.header("x-nonce");
  const ts = req.header("x-timestamp");
  if (!nonce || !ts) {
    res.status(400).json({ error: "CRYPTO_ERROR" });
    return null;
  }
  return { nonce, ts };
}

// /session/init/anon
app.post("/session/init/anon", async (req, res) => {
  const hdr = requireNonceTs(req, res);
  if (!hdr) return;

  // Replay protection
  try {
    await validateReplayProtection(redis, hdr.nonce, hdr.ts);
  } catch (e) {
    return res.status(400).json({ error: "CRYPTO_ERROR" });
  }

  const { clientPublicKey } = req.body;
  if (!clientPublicKey) return res.status(400).json({ error: "CRYPTO_ERROR" });

  const clientPub = unb64(clientPublicKey);

  // Public key validation
  try {
    validateP256PublicKey(clientPub);
  } catch (e) {
    return res.status(400).json({ error: "CRYPTO_ERROR" });
  }

  const { ecdh: serverECDH, publicKey: serverPub } = createEcdhKeypair();
  const sharedSecret = serverECDH.computeSecret(clientPub);

  // 128-bit session ID
  const sessionId = "A-" + crypto.randomBytes(16).toString("hex");
  const ttlSec = 120;

  const salt = Buffer.from(sessionId, "utf8");
  const info = Buffer.from("SESSION|A256GCM|ANON", "utf8");
  const sessionKey = hkdf32(sharedSecret, salt, info);

  await storeSession(sessionId, sessionKey, "ANON", ttlSec);

  res.json({ sessionId, serverPublicKey: b64(serverPub), encAlg: "A256GCM", expiresInSec: ttlSec });
});

// /session/init
app.post("/session/init", async (req, res) => {
  const hdr = requireNonceTs(req, res);
  if (!hdr) return;

  // Replay protection
  try {
    await validateReplayProtection(redis, hdr.nonce, hdr.ts);
  } catch (e) {
    return res.status(400).json({ error: "CRYPTO_ERROR" });
  }

  const auth = req.header("authorization");
  const token = auth?.startsWith("Bearer ") ? auth.slice(7) : undefined;

  const it = await introspectToken(token);
  if (!it.active) return res.status(401).json({ error: "INVALID_TOKEN" });

  const { clientPublicKey, ttlSec } = req.body;
  if (!clientPublicKey) return res.status(400).json({ error: "CRYPTO_ERROR" });

  const clientPub = unb64(clientPublicKey);

  // Public key validation
  try {
    validateP256PublicKey(clientPub);
  } catch (e) {
    return res.status(400).json({ error: "CRYPTO_ERROR" });
  }

  const { ecdh: serverECDH, publicKey: serverPub } = createEcdhKeypair();
  const sharedSecret = serverECDH.computeSecret(clientPub);

  // 128-bit session ID
  const sessionId = "S-" + crypto.randomBytes(16).toString("hex");
  const allowedTtl = Math.min(Math.max(ttlSec ?? 1800, 300), 3600);

  const salt = Buffer.from(sessionId, "utf8");
  const info = Buffer.from(`SESSION|A256GCM|AUTH|${it.clientId}|${it.sub}`, "utf8");
  const sessionKey = hkdf32(sharedSecret, salt, info);

  await storeSession(sessionId, sessionKey, "AUTH", allowedTtl, it.sub);

  res.json({ sessionId, serverPublicKey: b64(serverPub), encAlg: "A256GCM", expiresInSec: allowedTtl });
});

app.listen(3000, () => console.log("Session service listening on :3000"));
```

---

## 16) Security checklist summary

| # | Item | Priority | Status |
|---|---|---|---|
| 1 | Replay Protection (nonce + timestamp) | üî¥ Critical | Section 13 |
| 2 | Client Public Key Validation (P-256 curve check) | üî¥ Critical | Section 14.1 |
| 3 | Session ID Entropy (128 bits) | üü° Medium | Section 14.2 |
| 4 | IV Generation Rules | üü° Medium | Section 14.3 |
| 5 | Error Response Policy (generic errors) | üü° Medium | Section 14.4 |
| 6 | Rate Limiting (APIM config) | üü° Medium | Section 14.5 |

---

**End of document**
